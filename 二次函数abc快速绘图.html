<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>二次函数绘图：y = ax² + bx + c</title>
  <style>
    :root{--bg:#0b1020;--panel:#111a33;--text:#e8eeff;--muted:#a9b4d6;--line:#2a3a74;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Hiragino Sans GB","Noto Sans CJK SC",sans-serif;}
    .wrap{display:grid;grid-template-rows:auto 1fr;height:100%}
    header{padding:12px 14px}
    h1{margin:0;font-size:16px;font-weight:650}
    .content{display:grid;grid-template-columns:360px 1fr;gap:12px;padding:0 12px 12px;box-sizing:border-box;height:100%}
    @media(max-width:900px){.content{grid-template-columns:1fr;grid-template-rows:auto 1fr}}
    .panel{
      background:color-mix(in srgb,var(--panel) 92%, black);
      border:1px solid color-mix(in srgb,var(--line) 55%, black);
      border-radius:14px;padding:12px;box-shadow:0 10px 24px rgba(0,0,0,.25)
    }
    .row{display:grid;grid-template-columns:1fr 140px;gap:10px;align-items:center;margin:10px 0}
    label{font-size:13px}
    input[type="number"]{
      width:100%;box-sizing:border-box;padding:10px 10px;border-radius:10px;
      border:1px solid color-mix(in srgb,var(--line) 60%, black);
      background:rgba(255,255,255,.06);color:var(--text);font-size:14px;outline:none;
    }
    input[type="range"]{width:100%}
    .btns{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:8px}
    button{
      padding:10px 12px;border-radius:12px;border:1px solid color-mix(in srgb,var(--line) 60%, black);
      background:rgba(255,255,255,.06);color:var(--text);font-size:14px;font-weight:600;
      cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:manipulation;
    }
    button:active{transform:translateY(1px)}
    .status{
      margin-top:10px;padding:10px;border-radius:12px;background:rgba(255,255,255,.05);
      border:1px solid color-mix(in srgb,var(--line) 45%, black);font-size:13px;line-height:1.45;color:var(--text);
    }
    .canvasWrap{
      border:1px solid color-mix(in srgb,var(--line) 55%, black);
      border-radius:14px;overflow:hidden;position:relative;min-height:360px;
      background:radial-gradient(1200px 600px at 30% 30%, rgba(120,140,255,.18), transparent 55%),
               radial-gradient(900px 500px at 70% 65%, rgba(70,220,255,.10), transparent 60%),
               rgba(255,255,255,.03);
    }
    canvas{width:100%;height:100%;display:block;touch-action:none}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
  </style>
</head>
<body>
<div class="wrap">
  <header><h1>二次函数绘图：y = ax² + bx + c</h1></header>

  <div class="content">
    <div class="panel">
      <div class="row">
        <label>a</label>
        <input id="a" type="number" step="0.1" value="1" />
      </div>
      <div class="row">
        <label>b</label>
        <input id="b" type="number" step="0.1" value="0" />
      </div>
      <div class="row">
        <label>c</label>
        <input id="c" type="number" step="0.1" value="0" />
      </div>

      <div style="margin-top:14px;font-size:13px;color:var(--muted);">缩放（仅影响显示）</div>
      <div class="row" style="grid-template-columns:1fr 92px;margin-top:6px;">
        <input id="zoom" type="range" min="0.25" max="4" step="0.01" value="1" />
        <div class="mono" id="zoomVal" style="text-align:right;">1.00×</div>
      </div>

      <div class="btns">
        <button id="zoomIn">＋ 放大</button>
        <button id="zoomOut">－ 缩小</button>
        <button id="reset">↺ 重置</button>
      </div>

      <div class="status" id="status"></div>
    </div>

    <div class="canvasWrap">
      <canvas id="cv"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  const elA = document.getElementById('a');
  const elB = document.getElementById('b');
  const elC = document.getElementById('c');
  const elZoom = document.getElementById('zoom');
  const elZoomVal = document.getElementById('zoomVal');
  const status = document.getElementById('status');

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  let zoom = parseFloat(elZoom.value) || 1;

  // World coordinates: origin at center of canvas, +x right, +y up.
  const baseScalePx = 55; // pixels per 1 unit when zoom=1

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const r = cv.getBoundingClientRect();
    cv.width = Math.floor(r.width * dpr);
    cv.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }
  window.addEventListener('resize', resize, { passive: true });

  function fmt(n, k=3){
    if (!isFinite(n)) return '—';
    const f = Math.pow(10, k);
    return (Math.round(n*f)/f).toString();
  }

  function worldToScreen(x, y, scalePx, cx, cy){
    return { x: cx + x*scalePx, y: cy - y*scalePx };
  }

  function niceStep(unitsPerPx){
    const targetPx = 70;
    const raw = targetPx * unitsPerPx;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1,2,5,10];
    let best = candidates[0]*pow;
    let bestDiff = Math.abs(raw - best);
    for (const c of candidates){
      const v = c*pow;
      const diff = Math.abs(raw - v);
      if (diff < bestDiff){ bestDiff = diff; best = v; }
    }
    return best;
  }

  function drawAxes(scalePx, cx, cy, w, h){
    const unitsPerPx = 1/scalePx;
    const step = niceStep(unitsPerPx);

    // visible bounds in world units
    const left = (0 - cx)/scalePx;
    const right = (w - cx)/scalePx;
    const bottom = (cy - h)/scalePx;
    const top = (cy - 0)/scalePx;

    const xStart = Math.floor(left/step)*step;
    const xEnd = Math.ceil(right/step)*step;
    const yStart = Math.floor(bottom/step)*step;
    const yEnd = Math.ceil(top/step)*step;

    // grid
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    for (let x = xStart; x <= xEnd + 1e-9; x += step){
      const p = worldToScreen(x, 0, scalePx, cx, cy);
      ctx.beginPath(); ctx.moveTo(p.x, 0); ctx.lineTo(p.x, h); ctx.stroke();
    }
    for (let y = yStart; y <= yEnd + 1e-9; y += step){
      const p = worldToScreen(0, y, scalePx, cx, cy);
      ctx.beginPath(); ctx.moveTo(0, p.y); ctx.lineTo(w, p.y); ctx.stroke();
    }
    ctx.restore();

    // axes
    ctx.save();
    ctx.strokeStyle = 'rgba(232,238,255,0.85)';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
    ctx.restore();

    // axis labels
    ctx.save();
    ctx.fillStyle = 'rgba(232,238,255,0.92)';
    ctx.font = '14px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial';
    ctx.shadowColor = 'rgba(0,0,0,0.55)';
    ctx.shadowBlur = 6;
    ctx.fillText('x', w - 18, cy - 10);
    ctx.fillText('y', cx + 10, 18);
    ctx.restore();

    // tick labels
    ctx.save();
    ctx.fillStyle = 'rgba(232,238,255,0.75)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.shadowColor = 'rgba(0,0,0,0.55)';
    ctx.shadowBlur = 6;

    const tickPx = step * scalePx;
    const showEvery = tickPx < 55 ? 2 : 1;

    let idx = 0;
    for (let x = xStart; x <= xEnd + 1e-9; x += step){
      if (Math.abs(x) < 1e-12) { idx++; continue; }
      if (idx % showEvery === 0){
        const p = worldToScreen(x, 0, scalePx, cx, cy);
        ctx.fillText(fmt(x,2), p.x - 10, cy + 18);
      }
      idx++;
    }

    idx = 0;
    for (let y = yStart; y <= yEnd + 1e-9; y += step){
      if (Math.abs(y) < 1e-12) { idx++; continue; }
      if (idx % showEvery === 0){
        const p = worldToScreen(0, y, scalePx, cx, cy);
        ctx.fillText(fmt(y,2), cx + 8, p.y + 4);
      }
      idx++;
    }
    ctx.restore();
  }

  function drawCurve(a,b,c, scalePx, cx, cy, w, h){
    const left = (0 - cx)/scalePx;
    const right = (w - cx)/scalePx;

    const samples = Math.max(900, Math.floor(w*2));
    const dx = (right - left) / (samples - 1);

    ctx.save();
    ctx.strokeStyle = 'rgba(120,140,255,0.98)';
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    ctx.beginPath();
    let started = false;
    for (let i=0; i<samples; i++){
      const x = left + i*dx;
      const y = a*x*x + b*x + c;
      if (!isFinite(y)) continue;
      const p = worldToScreen(x, y, scalePx, cx, cy);
      if (!started){
        ctx.moveTo(p.x, p.y);
        started = true;
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    if (started) ctx.stroke();
    ctx.restore();
  }

  function computeKeyInfo(a,b,c){
    let vx = null, vy = null;
    if (Math.abs(a) > 1e-12){
      vx = -b/(2*a);
      vy = a*vx*vx + b*vx + c;
    }
    const y0 = c;
    const D = b*b - 4*a*c;
    return {vx, vy, y0, D};
  }

  function draw(){
    const w = cv.getBoundingClientRect().width;
    const h = cv.getBoundingClientRect().height;

    const a = parseFloat(elA.value);
    const b = parseFloat(elB.value);
    const c = parseFloat(elC.value);

    zoom = Math.max(0.25, Math.min(4, parseFloat(elZoom.value) || 1));
    elZoom.value = zoom.toFixed(2);
    elZoomVal.textContent = zoom.toFixed(2) + '×';

    const scalePx = baseScalePx * zoom;
    const cx = w/2, cy = h/2;

    ctx.clearRect(0,0,w,h);
    drawAxes(scalePx, cx, cy, w, h);
    drawCurve(a,b,c, scalePx, cx, cy, w, h);

    // vertex marker
    const info = computeKeyInfo(a,b,c);
    if (info.vx !== null && isFinite(info.vy)){
      const vp = worldToScreen(info.vx, info.vy, scalePx, cx, cy);
      ctx.save();
      ctx.fillStyle = 'rgba(255,235,120,0.98)';
      ctx.beginPath(); ctx.arc(vp.x, vp.y, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
    }

    const D = info.D;
    const rootInfo = (isFinite(D) && D >= 0 && Math.abs(a) > 1e-12)
      ? `实根：x = ${fmt((-b - Math.sqrt(D))/(2*a),3)}，${fmt((-b + Math.sqrt(D))/(2*a),3)}`
      : (Math.abs(a) <= 1e-12 ? '这不是二次函数（a≈0）' : (isFinite(D) ? '无实根' : '—'));

    status.innerHTML =
      `<div class="mono">y = ${fmt(a,3)}x² + ${fmt(b,3)}x + ${fmt(c,3)}</div>
       <div style="margin-top:6px" class="mono">顶点：${info.vx===null?'—':`(${fmt(info.vx,3)}, ${fmt(info.vy,3)})`}</div>
       <div style="margin-top:6px" class="mono">与 y 轴交点：(0, ${fmt(info.y0,3)})</div>
       <div style="margin-top:6px" class="mono">判别式 D = b² − 4ac = ${fmt(D,3)}</div>
       <div style="margin-top:6px" class="mono">${rootInfo}</div>`;
  }

  // controls
  [elA, elB, elC].forEach(el => {
    el.addEventListener('input', draw, { passive:true });
    el.addEventListener('change', draw, { passive:true });
  });
  elZoom.addEventListener('input', draw, { passive:true });

  document.getElementById('zoomIn').addEventListener('click', ()=>{
    zoom = Math.min(4, zoom * 1.15);
    elZoom.value = zoom.toFixed(2);
    draw();
  });
  document.getElementById('zoomOut').addEventListener('click', ()=>{
    zoom = Math.max(0.25, zoom / 1.15);
    elZoom.value = zoom.toFixed(2);
    draw();
  });
  document.getElementById('reset').addEventListener('click', ()=>{
    elA.value = 1;
    elB.value = 0;
    elC.value = 0;
    zoom = 1;
    elZoom.value = '1.00';
    draw();
  });

  // pinch zoom on canvas (iPad)
  let lastDist = null;
  cv.addEventListener('touchstart', (e)=>{
    if (e.touches && e.touches.length === 2){
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      lastDist = Math.hypot(dx,dy);
    }
  }, {passive:true});
  cv.addEventListener('touchmove', (e)=>{
    if (e.touches && e.touches.length === 2){
      e.preventDefault();
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.hypot(dx,dy);
      if (lastDist){
        const ratio = dist / lastDist;
        zoom = Math.max(0.25, Math.min(4, zoom * ratio));
        elZoom.value = zoom.toFixed(2);
        draw();
      }
      lastDist = dist;
    }
  }, {passive:false});
  cv.addEventListener('touchend', (e)=>{
    if (!e.touches || e.touches.length < 2) lastDist = null;
  }, {passive:true});

  // wheel zoom (desktop)
  cv.addEventListener('wheel', (e)=>{
    e.preventDefault();
    zoom *= (e.deltaY > 0) ? 0.92 : 1.08;
    zoom = Math.max(0.25, Math.min(4, zoom));
    elZoom.value = zoom.toFixed(2);
    draw();
  }, {passive:false});

  resize();
})();
</script>
</body>
</html>
